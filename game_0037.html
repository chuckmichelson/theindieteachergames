<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ski Jump Game - Clean Version</title>
  <style>
    body {
      background-color: #87CEEB;
      color: #fff;
      font-family: 'Georgia', serif;
      text-align: center;
      margin: 0;
      padding: 0;
      font-size: 18px;
      background: url('game_0037_foreground_2.png') no-repeat center bottom;
      background-size: cover;
      background-attachment: fixed;
      background-color: #121212; /* fallback color if image fails */
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      margin-top: 40px;
    }
    #equationLatex {
      position: absolute;
      bottom: -170px;          /* Pull up inside the window, nice and cozy */
      width: 35%;            /* Wider to center nicely */
      height: 15%;
      text-align: center;
      font-size: 28px;
      color: black;
      z-index: 3;
      pointer-events: none;  /* Allow clicks through */
      background: rgba(255, 255, 255, 0.7); /* Soft translucent background */
      padding: 3px 6px;     /* Cozy breathing space */
      border-radius: 12px;   /* Rounded corners */
      margin: 0 auto;
      left: 50%;
      transform: translateX(-50%); /* Perfect center horizontally */
    }


  </style>
  <script>
  window.MathJax = {
    tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]},
    svg: {fontCache: 'global'}
  };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div id="gameWrapper" style="position: relative; width: 1080px; height: 600px; margin: auto; border: none;">
  <canvas id="gameCanvas" width="1080" height="600" style="position: absolute; top: 0; left: 0; z-index: 1;"></canvas>
  <div id="equationLatex"></div>
</div>


<script>

// ==========================
// Constants and Assets
// ==========================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

const world = { minX: -12, maxX: 12, minY: -2, maxY: 12 };
const g = 1;
const possibleA = [-0.5, -1, -2];

const offsets = {
  jump: { x: -55, y: -96 },
  skier: { x: -30, y: -70 },
  fire: { x: -41, y: -90 }
};

const backgroundImage = new Image();
backgroundImage.src = 'game_0037_background_2.png';
const skierImage = new Image();
skierImage.src = 'game_0037_skier_2.png';
const jumpImage = new Image();
jumpImage.src = 'game_0037_jump_1.png';
const fireImage = new Image();
fireImage.src = 'game_0037_fire_1.png';


// ==========================
// State Variables
// ==========================
let skier = { x: 0, y: 0, vx: 0 };
let root1 = 0, root2 = 0, A = 0;
let ramp1 = 0, ramp2 = 0;
let vertexX = 0, vertexY = 0;
let launched = false, landed = false, readyToLaunch = false, allowInput = true;
let goingRight = true, reachedPeak = false;
let baseSpeed = 0;
let showAssist = true;
let flightSpeedMultiplier = 0; // Add this new state variable


// ==========================
// Utility Functions
// ==========================
function toCanvasX(x) {
  return ((x - world.minX) / (world.maxX - world.minX)) * width;
}
function toCanvasY(y) {
  return height - ((y - world.minY) / (world.maxY - world.minY)) * height;
}
function evaluateQuadratic(x, Aparam = A, r1 = root1, r2 = root2) {
  return Aparam * (x - r1) * (x - r2);
}

function slopeAtRoot(rootX) {
  return A * (2 * rootX - (root1 + root2));
}

function drawAssistParabola() {
  ctx.save();
  ctx.beginPath();
  let started = false;
  const step = 0.05; // smoothness of curve
  for (let x = root1; x <= root2; x += step) {
    const y = evaluateQuadratic(x, A, root1, root2);
    if (y > 0) {
      const cx = toCanvasX(x);
      const cy = toCanvasY(y);
      if (!started) {
        ctx.moveTo(cx, cy);
        started = true;
      } else {
        ctx.lineTo(cx, cy);
      }
    }
  }
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();
}

// ==========================
// Game Functions (MATH ONLY)
// ==========================
function updatePhysics() {
  if (!launched) return;

  if (!landed) {
    if (goingRight) {
      if (skier.x < root1) { // Approach
        skier.vx = baseSpeed;
        skier.y = 0;
      } else if (skier.x <= root2) { // Jump phase
        skier.vx = baseSpeed * flightSpeedMultiplier;
        skier.y = evaluateQuadratic(skier.x, A, root1, root2);
        if (skier.y > 0) reachedPeak = true;
        if (reachedPeak && skier.y <= 0) checkLanding();
      } else { // After jump
        skier.vx = baseSpeed;
        skier.y = 0;
        checkLanding();
      }
    } else {
      if (skier.x > root2) { // Approach
        skier.vx = -baseSpeed;
        skier.y = 0;
      } else if (skier.x >= root1) { // Jump phase
        skier.vx = -baseSpeed * flightSpeedMultiplier;
        skier.y = evaluateQuadratic(skier.x, A, root1, root2);
        if (skier.y > 0) reachedPeak = true;
        if (reachedPeak && skier.y <= 0) checkLanding();
      } else { // After jump
        skier.vx = -baseSpeed;
        skier.y = 0;
        checkLanding();
      }
    }
  } else {
    skier.vx = goingRight ? 0.1 : -0.1;
    skier.y = 0;
  }

  skier.x += skier.vx;
}

function launchSkier() {
  launched = true;
  readyToLaunch = false;
  allowInput = false;

  const h = Math.abs(vertexY);
  baseSpeed = Math.sqrt(2 * g * h) * 0.1;

  const launchSlope = goingRight ? slopeAtRoot(root1) : slopeAtRoot(root2);
  const launchAngle = Math.atan(launchSlope);
  flightSpeedMultiplier = Math.abs(Math.cos(launchAngle));

  skier.vx = goingRight ? baseSpeed : -baseSpeed;
}

function checkLanding() {
  if (landed) return;

  const tolerance = 0.4;
  const targetX = goingRight ? ramp2 : ramp1;

  if (Math.abs(skier.x - targetX) <= tolerance) {
    console.log("Perfect Landing!");
    landed = true;
    setTimeout(resetGame, 3000);
  } else {
    console.log("Crash Landing!");
    launched = false;
    setTimeout(resetGame, 2000);
  }
}

function generateNewEquation() {
  do {
    root1 = Math.floor(Math.random() * 17) - 6;
    root2 = Math.floor(Math.random() * 17) - 6;
  } while (root2 === root1 || Math.abs(root2 - root1) < 4);

  if (root1 > root2) [root1, root2] = [root2, root1];

  ramp1 = root1;
  ramp2 = root2;

  goingRight = Math.random() < 0.5;
  A = possibleA[Math.floor(Math.random() * possibleA.length)];

  vertexX = (root1 + root2) / 2;
  vertexY = evaluateQuadratic(vertexX, A, root1, root2);

  if (Math.abs(vertexY) > 9) {
    generateNewEquation();
    return;
  }

  if (Math.abs(root2 - root1) < 6 && Math.random() < 0.8) {
    // re-roll to make wider jumps happen sometimes
    return generateNewEquation();
  }

  skier.x = goingRight ? world.minX - 2 : world.maxX + 2;
  skier.y = 0;

  document.getElementById("equationLatex").innerHTML = `$$y = ${A}(x ${-root1 >= 0 ? '+' : ''}${-root1})(x ${-root2 >= 0 ? '+' : ''}${-root2})$$`;
  if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) MathJax.typesetPromise();
}

function resetGame() {
  skier = { x: 0, y: 0, vx: 0 };
  launched = false;
  landed = false;
  readyToLaunch = true;
  allowInput = true;
  reachedPeak = false;
  baseSpeed = 0;
  generateNewEquation();
}


// ==========================
// Draw Functions (RENDER ONLY)
// ==========================
function drawWorld() {
  ctx.clearRect(0, 0, width, height);
  if (backgroundImage.complete) ctx.drawImage(backgroundImage, 0, 0, width, height);

  drawGrid();
  drawJump();
  if (showAssist) {
    drawAssistParabola();
  }
  drawSkier();
  drawFire();
}


// drawGrid updated only
function drawGrid() {
  ctx.strokeStyle = 'darkgrey';
  ctx.lineWidth = 0.25;

  for (let x = Math.ceil(world.minX); x <= world.maxX; x++) {
    const cx = toCanvasX(x);
    ctx.beginPath();
    ctx.moveTo(cx, 0);
    ctx.lineTo(cx, height);
    if (Math.abs(x) < 0.001) {
      ctx.strokeStyle = 'darkgrey';
      ctx.lineWidth = 2;
    } else {
      ctx.strokeStyle = 'darkgrey';
      ctx.lineWidth = 0.5;
    }
    ctx.stroke();
  }

  for (let y = Math.ceil(world.minY); y <= world.maxY; y++) {
    const cy = toCanvasY(y);
    ctx.beginPath();
    ctx.moveTo(0, cy);
    ctx.lineTo(width, cy);
    if (Math.abs(y) < 0.001) {
      ctx.strokeStyle = 'darkgrey';
      ctx.lineWidth = 2;
    } else {
      ctx.strokeStyle = 'darkgrey';
      ctx.lineWidth = 0.5;
    }
    ctx.stroke();
  }
}


function drawJump() {
  if (!jumpImage.complete) return;
  ctx.drawImage(jumpImage, toCanvasX(ramp1) + offsets.jump.x, toCanvasY(0) + offsets.jump.y, 100, 100);
  drawMirroredImage(jumpImage, toCanvasX(ramp2) + offsets.jump.x, toCanvasY(0) + offsets.jump.y, 100, 100);
}

function drawFire() {
  if (!fireImage.complete) return;
  ctx.drawImage(fireImage, toCanvasX(vertexX) + offsets.fire.x, toCanvasY(vertexY) + offsets.fire.y, 80, 150);
}

function drawSkier() {
  if (!skierImage.complete || !launched) return;
  if (goingRight) {
    drawMirroredImage(skierImage, toCanvasX(skier.x) + offsets.skier.x, toCanvasY(skier.y) + offsets.skier.y, 60, 90);
  } else {
    ctx.drawImage(skierImage, toCanvasX(skier.x) + offsets.skier.x, toCanvasY(skier.y) + offsets.skier.y, 60, 90);
  }
}

function drawMirroredImage(img, x, y, w, h) {
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(img, -x - w, y, w, h);
  ctx.restore();
}


// ==========================
// Input Handling
// ==========================
document.addEventListener('keydown', (e) => {
  if (!allowInput) return;

  if (readyToLaunch) {
    if (e.key === ' ') {
      launchSkier();
    } else if (e.key === 'ArrowLeft') {
      if (goingRight) ramp2 -= 0.25;
      else ramp1 -= 0.25;
    } else if (e.key === 'ArrowRight') {
      if (goingRight) ramp2 += 0.25;
      else ramp1 += 0.25;
    }
  }
});


// ==========================
// Main Game Loop
// ==========================
function gameLoop() {
  updatePhysics();
  drawWorld();
  requestAnimationFrame(gameLoop);
}


// ==========================
// Start Game
// ==========================
if (typeof MathJax !== 'undefined' && MathJax.startup) {
  MathJax.startup.promise.then(() => {
    resetGame();
    gameLoop();
  });
} else {
  console.warn("MathJax startup not loaded. Starting immediately.");
  resetGame();
  gameLoop();
}

</script>

</body>
</html>
