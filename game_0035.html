<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <link rel="shortcut icon" href="favicon.ico">
  <script src="end-screen.js"></script>
  <link rel="stylesheet" href="end-screen.css">
  <meta charset="UTF-8">
  <title>Function Spells</title>
  <style>
    body {
      background-color: #121212;
      color: #fff;
      font-family: 'Georgia', serif;
      text-align: center;
      margin: 0;
      padding: 0;
      font-size: 18px;
      background: url('game_0035_background4.png') no-repeat center bottom;
      background-size: cover;
      background-attachment: fixed;
      background-color: #121212; /* fallback color if image fails */
    }
    canvas {
      display: block;
      margin: 40px auto;
      background-color: #1e1e1e;
      border: 2px solid #333;
      touch-action: none;
    }
    #feedback {
      font-size: 24px;
      margin-top: 10px;
    }
    #spell-popup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffe066;
      text-shadow: 0 0 10px #ffe066, 0 0 20px #ffaa33;
      opacity: 0;
      pointer-events: none;
      animation: none;
      font-family: 'Georgia', serif;
      z-index: 5;
      display: none;
    }
    @keyframes spellPop {
      0% { transform: translate(-50%, -50%) scale(0.4); opacity: 0; }
      20% { opacity: 1; transform: translate(-50%, -60%) scale(1.1); }
      50% { transform: translate(-50%, -63%) scale(1.0); opacity: 1; }
      100% { transform: translate(-50%, -65%) scale(1.0); opacity: 0; }
    }
    #bg {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
      background-size: cover;
      background-position: center bottom;
    }
    button {
      font-size: 24px;
      padding: 12px 24px;
      margin: 10px 0;
      cursor: pointer;
    }
    .hidden {
      display: none;
    }
    select {
      font-size: 32px;
      width: 220px;
    }
    #start-screen {
      text-align: center;
      padding: 2rem;
      font-family: sans-serif;
    }
    #overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5); /* semi-transparent black */
      z-index: 3; /* below turn-in screen, above gameplay */
    }
    #turn-in-screen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 0 20px #000;
      z-index: 4; /* on top */
      width: 400px;
      height: 550px;
    }
    #play-again-btn {
      font-size: 24px;
      padding: 12px 24px;
      margin: 10px 0;
      cursor: pointer;
      display: block;
    }


#function-types {
  display: grid;
  grid-template-columns: repeat(2, auto);
  gap: 0.75rem 2rem;
  justify-content: center;
  margin: 2rem auto;
  font-size: 20px;
  color: white;
}

#function-types label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 20px;
}

#function-types input[type="checkbox"] {
  width: 20px;
  height: 20px;
}


#difficulty-select {
  font-size: 20px;
  padding: 6px;
  border-radius: 8px;
  border: none;
  margin-top: 1rem;
}



  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
</head>
<body>
    <div id="start-screen">
      <h1>Function Spells</h1>
      <p>Cast a spell by drawing the function on the plane.</p>

      <div id="function-types">
        <label><input type="checkbox" value="linear" checked> Linear</label>
        <label><input type="checkbox" value="quadratic" checked> Quadratic</label>
        <label><input type="checkbox" value="root" checked> Root</label>
        <label><input type="checkbox" value="exponential" checked> Exponential</label>
        <label><input type="checkbox" value="logarithmic" checked> Logarithmic</label>
        <label><input type="checkbox" value="rational" checked> Rational</label>
        <label><input type="checkbox" value="cubic" checked> Cubic</label>
        <label><input type="checkbox" value="trig" checked> Trig</label>
        <label><input type="checkbox" value="step" checked> Step</label>
        <label><input type="checkbox" value="absolute" checked> Absolute Value</label>
      </div>

      <label for="difficulty-select">Wizardry:</label><br>
      <select id="difficulty-select">
        <option value="1">ðŸ§™ Muggle</option>
        <option value="3">ðŸ§™ðŸ§™ Apprentice</option>
        <option value="5">ðŸ§™ðŸ§™ðŸ§™ Adept</option>
        <option value="10">ðŸ§™ðŸ§™ðŸ§™ðŸ§™ Mage</option>
        <option value="infinity">ðŸ§™ðŸ§™ðŸ§™ðŸ§™ðŸ§™ Sorcerer</option>
      </select>

      <br><br>
      <button onclick="startGame()">Start Game</button>
    </div>


    <br>
  </div>

  <div id="game-screen" style="display:none;">
    <div id="bg"></div>
    <canvas id="spellCanvas" width="500" height="500"></canvas>
    <div id="equationLatex" style="margin-top: 1.5vh; font-size: 36px;"></div>
    <p id="feedback"></p>
    <div id="spell-popup"></div>
  </div>

  <div id="turn-in-screen" class="hidden">
    <h2>Well Done!</h2>
    <p id="summary-again"></p>

    <!-- ðŸ‘‡ MOVE END BUTTONS TO HERE -->
    <div id="end-buttons" style="margin-top: 1.5rem; display: flex; justify-content: center; gap: 20px;">
      <button class="submit-btn" id="play-again-btn" onclick="restartGame()">Play Again</button>
      <button class="submit-btn" id="new-settings-btn" onclick="location.reload()">New Settings</button>
    </div>

    <div id="turn-in-details" style="margin-top: 2rem;">
      <p>Enter your initials:</p>
      <div id="initials-boxes">
        <input class="initial-box" id="initial-0" maxlength="1" type="text"/>
        <input class="initial-box" id="initial-1" maxlength="1" type="text"/>
        <input class="initial-box" id="initial-2" maxlength="1" type="text"/>
      </div>
      <textarea id="student-comments" placeholder="Comments (optional)"></textarea>
      <button class="submit-btn" onclick="handleSubmission()">Send</button>
      <p id="submit-status"></p>
    </div>
  </div>

  <div id="overlay" class="hidden"></div>


  <script>
    const canvas = document.getElementById("spellCanvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const feedback = document.getElementById("feedback");

    let assistOpacity = 0;    // 0 to 1
    let assistFullyDrawn = false;

    const worldMinX = -10, worldMaxX = 10;
    const worldMinY = -10, worldMaxY = 10;

    const choices = [-3, -2, -1, -0.5, 0.5, 1, 2, 3];
    const functionCoefficient = choices[Math.floor(Math.random() * choices.length)];
    const functionConstant = choices[Math.floor(Math.random() * choices.length)];

    let assistTimeoutId = null;
    let assistAllowed = false;

    const spellIncantations = {
      linear: "Linus Lux!",
      quadratic: "Quadraticus Arcana!",
      root: "Lumina Radicalis!",
      exponential: "Ignis Exponentia!",
      logarithmic: "Logarithmus Dimini!",
      rational: "Rationalis Supra!",
      cubic: "Cubicus Vortexi!",
      trig: "Trigonis Oscillare!",
      step: "Gradatum Terra!",
      absolute: "Absolutum Valore!"
    };
    let currentSpellName = spellIncantations.linear;
    let currentFunctionType = "linear";

    const difficultyNames = {
      "1": "Muggle",
      "3": "Apprentice",
      "5": "Adept",
      "10": "Mage",
      "infinity": "Sorcerer"
    };

    let freezeGreen = false;

    function triggerSpellPopup(spellName) {
      const popup = document.getElementById("spell-popup");
      popup.textContent = spellName;
      popup.style.display = "block";
      popup.style.animation = "none";
      void popup.offsetWidth;
      popup.style.animation = "spellPop 1.8s ease-out";
      setTimeout(() => {
        popup.style.display = "none";
        popup.textContent = "";
      }, 1800);
    }

    let targetFunction = (x) => functionCoefficient * x + functionConstant;

    const aLatex = formatCoefficientLatex(functionCoefficient);
    const bRounded = Math.round(functionConstant);

    const sign = bRounded >= 0 ? '+' : '-';
    const bLatex = Math.abs(bRounded).toString();

    window.addEventListener('load', () => {
      const latexString = formatLinearEquationLatex(functionCoefficient, functionConstant);
      document.getElementById("equationLatex").innerHTML = `\\(${latexString}\\)`;
      MathJax.typesetPromise();
    });


    let selectedFunctionTypes = [];
    let assistDelay = 0;
    let currentProblemIndex = 0;
    const totalProblems = 10;
    let startTime = 0;
    let endTime = 0;

    function startGame() {
      // Hide start screen, show game screen
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-screen').style.display = 'block';

      // Read selected function types
      selectedFunctionTypes = [];
      document.querySelectorAll('#function-types input[type="checkbox"]:checked').forEach(cb => {
        selectedFunctionTypes.push(cb.value);
      });

      if (selectedFunctionTypes.length === 0) {
        alert("Please select at least one function type!");
        location.reload();
        return;
      }

      // Read selected difficulty
      const difficultyValue = document.getElementById('difficulty-select').value;
      assistDelay = difficultyValue === 'infinity' ? Infinity : parseFloat(difficultyValue) * 1000; // ms

      // Reset counters
      currentProblemIndex = 0;

      // Start timing
      startTime = performance.now();

      // Begin first problem
      loadNextProblem();
    }


    function restartGame() {

      if (assistTimeoutId !== null) {
        clearTimeout(assistTimeoutId);
        assistTimeoutId = null;
      }

      // Hide overlay and turn-in screen
      document.getElementById('overlay').classList.add('hidden');
      const turnInScreen = document.getElementById('turn-in-screen');
      turnInScreen.classList.add('hidden');
      turnInScreen.style.display = 'none';

      // Clear initials fields and restore background color
      for (let i = 0; i < 3; i++) {
        const box = document.getElementById(`initial-${i}`);
        box.value = '';
        box.style.backgroundColor = '#fff';  // Reset to white
      }

      // Clear comments and submit status
      document.getElementById('student-comments').value = '';
      document.getElementById('submit-status').textContent = '';

      // Reset key variables
      currentProblemIndex = 0;
      startTime = performance.now();
      freezeGreen = false;

      // Reset canvas
      userTrace = [];
      isCorrect = false;
      isCorrectFinal = false;
      assistOpacity = 0;
      assistFullyDrawn = false;

      ctx.clearRect(0, 0, width, height);
      drawGridAndAxes();

      // Start next problem immediately
      loadNextProblem();
    }




    function revealTurnIn() {
      document.getElementById("turn-in-details").style.display = "block";
      document.getElementById("initial-0").focus();
    }


    if (assistTimeoutId !== null) {
      clearTimeout(assistTimeoutId);
      assistTimeoutId = null;
    }


    function loadNextProblem() {
      // --- Reset assist system ---
      if (assistTimeoutId !== null) {
        clearTimeout(assistTimeoutId);
        assistTimeoutId = null;
      }
      assistOpacity = 0;
      assistFullyDrawn = false;
      assistAllowed = (assistDelay !== Infinity);

      // --- End game if finished ---
      if (currentProblemIndex >= totalProblems) {
        endGame();
        return;
      }

      currentProblemIndex++;

      // --- Clear previous traces ---
      userTrace = [];
      isCorrect = false;
      isCorrectFinal = false;
      ctx.clearRect(0, 0, width, height);
      drawGridAndAxes();

      // --- Pick a new function type ---
      const funcType = selectedFunctionTypes[Math.floor(Math.random() * selectedFunctionTypes.length)];
      currentFunctionType = funcType;
      currentSpellName = spellIncantations[funcType];

      // --- Generate a new random function ---
      const { func, latex } = generateFunction(funcType);
      targetFunction = func;

      // --- Display the equation ---
      document.getElementById("equationLatex").innerHTML = `\\(${latex}\\)`;
      MathJax.typesetPromise();

      // --- Set up assist if allowed ---
      if (assistAllowed) {
        assistTimeoutId = setTimeout(() => {
          fadeInAssist();
        }, assistDelay);
      }
    }



    function fadeInAssist() {
      if (!assistAllowed) {
        return; // Prevent assist if not allowed
      }
      assistOpacity = 0;
      function animate() {
        assistOpacity += 0.001;  // control speed of fade
        if (assistOpacity > 1) assistOpacity = 1;
        redrawTrace();
        if (assistOpacity < 1) {
          requestAnimationFrame(animate);
        }
      }
      requestAnimationFrame(animate);
    }


    function generateFunction(type) {
      const bChoices = [-5, -3, -1, 0, 1, 3, 5];
      const shifts = [-3, -2, -1, 0, 1, 2, 3]; // gentle shifts
      const scaleChoices = [-2, -1, 1, 2];

      const randomChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const formatShift = (h) => {
        if (h === 0) return "x";
        return `(x ${h >= 0 ? '-' : '+'} ${Math.abs(h)})`;
      };

      const formatPlusK = (k) => {
        if (k === 0) return "";
        return ` ${k > 0 ? '+ ' : '- '}${Math.abs(k)}`;
      };

      switch (type) {
        case "linear":
          const m = randomChoice(scaleChoices);
          const b = randomChoice(bChoices);
          return {
            func: (x) => m * x + b,
            latex: m === 1 ? `y = x${formatPlusK(b)}`
                 : m === -1 ? `y = -x${formatPlusK(b)}`
                 : `y = ${m}x${formatPlusK(b)}`
          };

        case "quadratic":
          const a = randomChoice(scaleChoices);
          const h = randomChoice(shifts);
          const k = randomChoice(bChoices);
          return {
            func: (x) => a * (x - h) * (x - h) + k,
            latex: a === 1
              ? `y = ${formatShift(h)}^2${formatPlusK(k)}`
              : a === -1
              ? `y = -${formatShift(h)}^2${formatPlusK(k)}`
              : `y = ${a}${formatShift(h)}^2${formatPlusK(k)}`
          };

        case "root":
          const hRoot = randomChoice(shifts.filter(x => x >= -2)); // avoid too negative
          const kRoot = randomChoice(bChoices);
          return {
            func: (x) => (x - hRoot >= 0 ? Math.sqrt(x - hRoot) + kRoot : NaN),
            latex: `y = \\sqrt{${formatShift(hRoot)}}${formatPlusK(kRoot)}`
          };

        case "exponential":
          const kExp = randomChoice(scaleChoices);
          const hExp = randomChoice(shifts);
          const vExp = randomChoice(bChoices);
          return {
            func: (x) => Math.exp(kExp * (x - hExp)) + vExp,
            latex: `y = e^{${kExp}${formatShift(hExp)}}${formatPlusK(vExp)}`
          };

        case "logarithmic":
          const hLog = randomChoice(shifts.filter(x => x >= -2));
          const kLog = randomChoice(bChoices);
          return {
            func: (x) => (x - hLog > 0 ? Math.log(x - hLog) + kLog : NaN),
            latex: `y = \\ln{${formatShift(hLog)}}${formatPlusK(kLog)}`
          };

        case "rational":
          const hRat = randomChoice(shifts.filter(x => x !== 0));
          const kRat = randomChoice(bChoices);
          return {
            func: (x) => (x - hRat !== 0 ? 1 / (x - hRat) + kRat : NaN),
            latex: `y = \\frac{1}{${formatShift(hRat)}}${formatPlusK(kRat)}`
          };

        case "cubic":
          const aCubic = randomChoice(scaleChoices);
          const hCubic = randomChoice(shifts);
          const kCubic = randomChoice(bChoices);
          return {
            func: (x) => aCubic * Math.pow(x - hCubic, 3) + kCubic,
            latex: aCubic === 1
              ? `y = ${formatShift(hCubic)}^3${formatPlusK(kCubic)}`
              : aCubic === -1
              ? `y = -${formatShift(hCubic)}^3${formatPlusK(kCubic)}`
              : `y = ${aCubic}${formatShift(hCubic)}^3${formatPlusK(kCubic)}`
          };

        case "trig":
          const shiftTrig = randomChoice(shifts);
          return {
            func: (x) => Math.sin(x - shiftTrig),
            latex: `y = \\sin${formatShift(shiftTrig)}`
          };

        case "step":
          const shiftStep = randomChoice(shifts);
          return {
            func: (x) => Math.floor(x - shiftStep),
            latex: `y = \\lfloor ${formatShift(shiftStep)} \\rfloor`
          };
        case "absolute":
          const hAbs = randomChoice(shifts);
          const kAbs = randomChoice(bChoices);
          return {
            func: (x) => Math.abs(x - hAbs) + kAbs,
            latex: `y = \\left|${formatShift(hAbs)}\\right|${formatPlusK(kAbs)}`
          };


        default:
          return generateFunction("linear");
      }
    }




    function endGame() {
      endTime = performance.now();
      const elapsedSeconds = ((endTime - startTime) / 1000).toFixed(2);

      document.getElementById('overlay').classList.remove('hidden');

      const turnInScreen = document.getElementById('turn-in-screen');
      turnInScreen.classList.remove('hidden');
      turnInScreen.style.display = 'block';

      // Reset initials and background color
      for (let i = 0; i < 3; i++) {
        const box = document.getElementById(`initial-${i}`);
        box.value = '';
        box.style.backgroundColor = '#fff';
      }

      // Clear comments and submit status
      document.getElementById('student-comments').value = '';
      document.getElementById('submit-status').textContent = '';

      // Focus the first initial box immediately
      document.getElementById('initial-0').focus();

      // Update summary
      document.getElementById('summary-again').textContent = `Completed ${totalProblems} spells in ${elapsedSeconds} seconds!`;
    }



    function handleSubmission() {
      const initials = [...Array(3)].map((_, i) => document.getElementById(`initial-${i}`).value.toUpperCase()).join('');
      const comments = document.getElementById("student-comments").value;

      const difficultySelect = document.getElementById('difficulty-select');
      const selectedDifficultyValue = difficultySelect.value;
      const difficulty = difficultyNames[selectedDifficultyValue];

      const functionList = selectedFunctionTypes.join(', ');

      const elapsedSeconds = ((endTime - startTime) / 1000).toFixed(2);

      const payload = {
        game: "game_0035",
        settings: `${functionList}; ${difficulty}`,
        score: `${totalProblems}; ${totalProblems}`,
        elapsed: `${elapsedSeconds} seconds`,
        initials,
        comments
      };

      submitResults(payload); // assuming you use a Formspree / Sheets integration like before
    }

    function toCanvasX(x) {
      return ((x - worldMinX) / (worldMaxX - worldMinX)) * width;
    }

    function toCanvasY(y) {
      return height - ((y - worldMinY) / (worldMaxY - worldMinY)) * height;
    }

    function drawAssistGraph() {
      ctx.save();
      ctx.globalAlpha = assistOpacity;
      ctx.beginPath();
      let started = false;
      for (let x = worldMinX; x <= worldMaxX; x += 0.1) {
        const y = targetFunction(x);
        const cx = toCanvasX(x);
        const cy = toCanvasY(y);
        if (!started) { ctx.moveTo(cx, cy); started = true; }
        else { ctx.lineTo(cx, cy); }
      }
      ctx.strokeStyle = "#cccccc";  // gray assist
      ctx.lineWidth = 2;
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.restore();
    }


    function drawGridAndAxes() {
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      for (let x = Math.ceil(worldMinX); x <= worldMaxX; x++) {
        const cx = toCanvasX(x);
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, height);
        ctx.stroke();
      }
      for (let y = Math.ceil(worldMinY); y <= worldMaxY; y++) {
        const cy = toCanvasY(y);
        ctx.beginPath();
        ctx.moveTo(0, cy);
        ctx.lineTo(width, cy);
        ctx.stroke();
      }
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, toCanvasY(0));
      ctx.lineTo(width, toCanvasY(0));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toCanvasX(0), 0);
      ctx.lineTo(toCanvasX(0), height);
      ctx.stroke();
    }

    let userTrace = [];
    let isCorrect = false;
    let isCorrectFinal = false;
    const threshold = 2;

    function redrawTrace() {
      ctx.clearRect(0, 0, width, height);
      drawGridAndAxes();

      // Always draw assist if any opacity
      if (assistOpacity > 0) {
        drawAssistGraph();
      }

      // Then draw user trace
      if (userTrace.length === 0) return;
      
      const color = (freezeGreen || isCorrect) ? "#00ff88" : "#ffaa33";
      ctx.beginPath();
      userTrace.forEach((pt, i) => {
        const cx = toCanvasX(pt.x);
        const cy = toCanvasY(pt.y);
        if (i === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      });
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.shadowColor = color;
      ctx.shadowBlur = 30;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }



    function calculateLSE() {
      if (userTrace.length < 10) return Infinity;
      let error = 0;
      for (const pt of userTrace) {
        const expectedY = targetFunction(pt.x);
        error += (expectedY - pt.y) ** 2;
      }
      return error / userTrace.length;
    }

    function evaluateTrace() {
      const lse = calculateLSE();
      isCorrect = lse < threshold;
      feedback.textContent = isCorrect ? "" : "";
      redrawTrace();
    }

    function startTrace(e) {
      e.preventDefault();
      userTrace = [];
      isCorrect = false;
      addPoint(e);
    }

    function addPoint(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const x = (clientX - rect.left) / (width / (worldMaxX - worldMinX)) + worldMinX;
      const y = worldMaxY - (clientY - rect.top) / (height / (worldMaxY - worldMinY));
      userTrace.push({ x, y });
      evaluateTrace();
    }

    canvas.addEventListener("mousedown", startTrace);
    canvas.addEventListener("mousemove", (e) => { if (e.buttons === 1) addPoint(e); });
    canvas.addEventListener("touchstart", startTrace, { passive: false });
    canvas.addEventListener("touchmove", (e) => { addPoint(e); e.preventDefault(); }, { passive: false });
    canvas.addEventListener("mouseup", handleRelease);
    canvas.addEventListener("touchend", handleRelease, { passive: false });

    redrawTrace();

    function handleRelease(e) {
      const traceLength = calculateTraceLength();
      const minimumLength = 4; // adjust this if needed

      if (isCorrect && (traceLength > minimumLength)) {
        // RIGHT AWAY: lock the color green
        freezeGreen = true;
        isCorrectFinal = true;

        triggerSpellPopup(currentSpellName);

        assistOpacity = 1;
        assistFullyDrawn = true;
        startGreenTraceAnimation();

        setTimeout(() => {
          freezeGreen = false; // reset for next problem
          loadNextProblem();
        }, 2500);

      } else {
        if (!freezeGreen) { 
          isCorrectFinal = false;
          vanishSpell();
        }
      }
    }



    function calculateTraceLength() {
      let total = 0;
      for (let i = 1; i < userTrace.length; i++) {
        const dx = userTrace[i].x - userTrace[i-1].x;
        const dy = userTrace[i].y - userTrace[i-1].y;
        total += Math.sqrt(dx*dx + dy*dy);
      }
      return total;
    }


    function vanishSpell() {
      let fade = 1;

      function animate() {
        ctx.clearRect(0, 0, width, height);
        drawGridAndAxes();

        if (userTrace.length > 0) {
          ctx.save();
          ctx.globalAlpha = fade;
          ctx.beginPath();
          userTrace.forEach((pt, i) => {
            const cx = toCanvasX(pt.x);
            const cy = toCanvasY(pt.y);
            if (i === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
          });
          ctx.strokeStyle = "#ffaa33"; // fading out orange
          ctx.lineWidth = 4;
          ctx.shadowColor = "#ffaa33";
          ctx.shadowBlur = 20;
          ctx.stroke();
          ctx.restore();
        }

        fade -= 0.05;
        if (fade > 0) {
          requestAnimationFrame(animate);
        } else {
          userTrace = [];
          isCorrect = false;
          isCorrectFinal = false;
          redrawTrace();
        }
      }

      requestAnimationFrame(animate);
    }


    function startGreenTraceAnimation() {
      let progress = 0;
      const duration = 2000; // ms

      function animate() {
        const now = performance.now();
        progress += 16; // about 60fps
        const t = Math.min(progress / duration, 1);

        ctx.clearRect(0, 0, width, height);
        drawGridAndAxes();

        // Fade out user trace
        if (userTrace.length > 0) {
          ctx.save();
          ctx.globalAlpha = 1 - t;
          const color = freezeGreen ? "#00ff88" : "#ffaa33"; // green if frozen
          ctx.beginPath();
          userTrace.forEach((pt, i) => {
            const cx = toCanvasX(pt.x);
            const cy = toCanvasY(pt.y);
            if (i === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
          });
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.shadowColor = color;
          ctx.shadowBlur = 30;
          ctx.stroke();
          ctx.restore();
        }

        // Draw partial green assist
        ctx.save();
        ctx.beginPath();
        let started = false;
        let stopX = worldMinX + (worldMaxX - worldMinX) * t;
        for (let x = worldMinX; x <= stopX; x += 0.1) {
          const y = targetFunction(x);
          const cx = toCanvasX(x);
          const cy = toCanvasY(y);
          if (!started) { ctx.moveTo(cx, cy); started = true; }
          else { ctx.lineTo(cx, cy); }
        }
        ctx.strokeStyle = "#00ff88";  // magical green
        ctx.lineWidth = 4;
        ctx.shadowColor = "#00ff88";
        ctx.shadowBlur = 20;
        ctx.stroke();
        ctx.restore();

        if (t < 1) {
          requestAnimationFrame(animate);
        }
      }

      requestAnimationFrame(animate);
    }


    function formatCoefficientLatex(coef) {
      const isInteger = Math.abs(coef - Math.round(coef)) < 1e-6;
      if (isInteger) {
        if (coef === 1) return '';
        if (coef === -1) return '-';
        return coef.toString();
      }

      const frac = simplifyFraction(coef);
      return `\\frac{${frac.numerator}}{${frac.denominator}}`;
    }

    function simplifyFraction(decimal) {
      const precision = 1000;
      let numerator = Math.round(decimal * precision);
      let denominator = precision;

      const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
      const divisor = gcd(Math.abs(numerator), denominator);

      return {
        numerator: numerator / divisor,
        denominator: denominator / divisor
      };
    }


    function formatLinearEquationLatex(a, b) {
      let aStr = '';
      if (Math.abs(a - Math.round(a)) < 1e-6) {
        // Integer coefficient
        if (a === 1) aStr = 'x';
        else if (a === -1) aStr = '-x';
        else aStr = `${a}x`;
      } else {
        // Fractional coefficient
        const numerator = Math.round(a * 10);
        const denominator = 10;
        aStr = `\\frac{${numerator}}{${denominator}}x`;
      }

      const bRounded = Math.round(b);
      const bStr = bRounded > 0 ? `+ ${bRounded}` : bRounded < 0 ? `- ${Math.abs(bRounded)}` : '';

      return `y = ${aStr} ${bStr}`;
    }

    window.addEventListener('load', () => {
      for (let i = 0; i < 3; i++) {
        const box = document.getElementById(`initial-${i}`);
        box.addEventListener('input', () => {
          if (box.value.trim() !== "") {
            box.style.backgroundColor = "#00ff88"; // light green
          } else {
            box.style.backgroundColor = "#fff"; // back to white if emptied
          }
        });
      }
    });


  </script>
</body>
</html>